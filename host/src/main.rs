// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use clap::{Parser, ValueEnum};
use db_access::queries::get_block_headers_by_block_range;
use db_access::DbConnection;
use fixed::{types::extra::U64, FixedI128};
use methods::{PRICING_FIXED_ELF, PRICING_FLOAT_ELF};
use risc0_zkvm::{default_prover, ExecutorEnv};
use tokio::task;

#[derive(Copy, Clone, PartialEq, Eq, ValueEnum, Debug)]
enum PricingMethod {
    Float,
    Fixed,
}

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Start block number
    #[arg(long)]
    start_block: i64,

    /// End block number
    #[arg(long)]
    end_block: i64,

    /// Path to .env file
    #[arg(long, default_value = ".env")]
    env_file: String,

    /// Pricing method to use
    #[arg(long, value_enum)]
    method: PricingMethod,
}

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    let args = Args::parse();

    // Load environment variables from specified file
    dotenv::from_path(&args.env_file).ok();

    run_host(args.start_block, args.end_block, args.method).await?;
    Ok(())
}

async fn run_host(
    start_block: i64,
    end_block: i64,
    method: PricingMethod,
) -> Result<(Option<f64>, Option<f64>), sqlx::Error> {
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let db = DbConnection::new().await?;
    let block_headers = get_block_headers_by_block_range(&db.pool, start_block, end_block).await?;

    let prove_info = task::spawn_blocking(move || {
        let env = ExecutorEnv::builder()
            .write(&block_headers)
            .unwrap()
            .build()
            .unwrap();
        let prover = default_prover();

        match method {
            PricingMethod::Float => prover.prove(env, PRICING_FLOAT_ELF).unwrap(),
            PricingMethod::Fixed => prover.prove(env, PRICING_FIXED_ELF).unwrap(),
        }
    })
    .await
    .unwrap();

    let receipt = prove_info.receipt;

    let (volatility, twap) = match method {
        PricingMethod::Float => {
            let (v, t): (Option<f64>, Option<f64>) = receipt.journal.decode().unwrap();
            (v, t)
        }
        PricingMethod::Fixed => {
            let (v, t): (Option<FixedI128<U64>>, Option<FixedI128<U64>>) =
                receipt.journal.decode().unwrap();
            (v.map(|x| x.to_num::<f64>()), t.map(|x| x.to_num::<f64>()))
        }
    };

    println!("HOST");
    println!("Method: {:?}", method);
    println!("Volatility: {:?}", volatility);
    println!("TWAP: {:?}", twap);

    Ok((volatility, twap))
}
